=>MY_VERSION
void draw_ray(t_data *p_img, t_player *player, t_vector *direction)
{
	// if ((direction->y == player->p_y) && (direction->x == player->p_x))
	// 	return;
	float i = 0;
	float steps;
	float x_inc;
	float y_inc;
	int	 x = player->p_x;
	int	 y = player->p_y;
	float dy = (direction->y - player->p_y);
	float dx = (direction->x - player->p_x);


	if (fabs(dx) >= fabs(dy))
		steps = fabs(dx);
	else
		steps = fabs(dy);

	x_inc = dx / steps;
	y_inc = dy / steps;

	while (i < steps)
	{
		my_mlx_pixel_put(p_img, (int)x, (int)y, BLUE);
		x += x_inc;
		y += y_inc;
		i ++;
	}
}

=>GPT'S
void draw_ray(t_player *player, t_data *p_img, int color)
{
    int x1 = (int)player->p_x;
    int y1 = (int)player->p_y;
    int x2 = (int)(player->p_x + player->direction->x * 200);
    int y2 = (int)(player->p_y + player->direction->y * 200);

    float dx = x2 - x1;
    float dy = y2 - y1;
    float steps = fabs(dy);
	if (fabs(dx) > fabs(dy))
		steps = fabs(dx);
    float x_inc = dx / steps;
    float y_inc = dy / steps;

    float x = x1;
    float y = y1;

    for (int i = 0; i < steps; i++)
    {
		my_mlx_pixel_put(p_img, (int)x, (int)y, color);
        x += x_inc;
        y += y_inc;
    }
}
